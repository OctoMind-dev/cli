import fsPromises from "fs/promises";
import path from "path";

import type { components, paths } from "../api"; // generated by openapi-typescript
import { findOctomindFolder } from "../helpers";
import { logger } from "../logger";
import { getUrl } from "../url";
import { BASE_URL, client, handleError, ListOptions, logJson } from "./client";
import { getEnvironments } from "./environments";
import { buildFilename, readTestCasesFromDir } from "./sync/yaml";

export type TestCaseResponse = components["schemas"]["TestCaseResponse"];
export type TestCasesResponse = components["schemas"]["TestCasesResponse"];
export type GetTestCaseParams =
  paths["/apiKey/v3/test-targets/{testTargetId}/test-cases/{testCaseId}"]["get"]["parameters"]["path"];
export type DeleteTestCaseParams =
  paths["/apiKey/v3/test-targets/{testTargetId}/test-cases/{testCaseId}"]["delete"]["parameters"]["path"];

export const deleteTestCase = async (
  options: DeleteTestCaseParams & ListOptions,
): Promise<void> => {
  const octomindRoot = await findOctomindFolder();

  if (!octomindRoot) {
    const { data, error } = await client.DELETE(
      "/apiKey/v3/test-targets/{testTargetId}/test-cases/{testCaseId}",
      {
        params: {
          path: {
            testTargetId: options.testTargetId,
            testCaseId: options.testCaseId,
          },
        },
      },
    );

    handleError(error);
    if (options.json) {
      logJson(data);
    }
    logger.info("Test Case deleted successfully");
    return;
  }

  const testCases = readTestCasesFromDir(octomindRoot);
  const testCasesById = Object.fromEntries(testCases.map((tc) => [tc.id, tc]));
  const existingTestCase = testCasesById[options.testCaseId];

  if (!existingTestCase) {
    logger.info(
      `No test case with id ${options.testCaseId} found in folder ${octomindRoot}`,
    );
    return;
  }

  const existingTestCasePath = buildFilename(existingTestCase, octomindRoot);
  await fsPromises.unlink(path.join(octomindRoot, existingTestCasePath));
  logger.info("Test Case deleted successfully");
};

export const listTestCase = async (
  options: GetTestCaseParams & ListOptions,
): Promise<void> => {
  const { data, error } = await client.GET(
    "/apiKey/v3/test-targets/{testTargetId}/test-cases/{testCaseId}",
    {
      params: {
        path: {
          testTargetId: options.testTargetId,
          testCaseId: options.testCaseId,
        },
      },
    },
  );

  handleError(error);

  const response = data as TestCaseResponse;

  if (options.json) {
    logJson(response);
    return;
  }

  logger.info("Test Case Details:");
  logger.info(`ID: ${response.id}`);
  logger.info(`Description: ${response.description}`);
  logger.info(`Status: ${response.status}`);
  logger.info(`Run Status: ${response.runStatus}`);
  logger.info(`Created At: ${response.createdAt}`);
  logger.info(`Updated At: ${response.updatedAt}`);

  if (response.elements && response.elements.length > 0) {
    logger.info("\nElements:");
    response.elements.forEach((element, index) => {
      logger.info(`\nElement ${index + 1}:`);
      if (element.interaction) {
        logger.info(`  Action: ${element.interaction.action}`);
        if (element.interaction.calledWith) {
          logger.info(`  Called With: ${element.interaction.calledWith}`);
        }
      }
      if (element.assertion) {
        logger.info(`  Expectation: ${element.assertion.expectation}`);
        if (element.assertion.calledWith) {
          logger.info(`  Called With: ${element.assertion.calledWith}`);
        }
      }
      logger.info("  Selectors:");
      element.selectors?.forEach((selector) => {
        logger.info(`    - ${selector.selectorType}: ${selector.selector}`);
        if (selector.options?.name) {
          logger.info(`      Name: ${selector.options.name}`);
        }
      });
    });
  }
};

export type GetTestCasesOptions = {
  testTargetId: string;
  status?: string;
  runStatus?: string;
  bearerToken?: string;
};
export const getTestCases = async (
  options: GetTestCasesOptions,
): Promise<TestCasesResponse> => {
  if (options.bearerToken) {
    const url = new URL(
      `${BASE_URL}/api/bearer/v1/test-targets/${options.testTargetId}/test-cases`,
    );
    if (options.status || options.runStatus) {
      url.searchParams.set(
        "filter",
        JSON.stringify({
          status: options.status,
          runStatus: options.runStatus,
        }),
      );
    }
    const res = await fetch(url, {
      headers: {
        Authorization: `Bearer ${options.bearerToken}`,
      },
    });
    if (res.ok) {
      const response = await res.json();
      return response;
    }
    throw new Error(`no test cases found. error: ${res.statusText}`);
  }
  const { data, error } = await client.GET(
    "/apiKey/v3/test-targets/{testTargetId}/test-cases",
    {
      params: {
        path: {
          testTargetId: options.testTargetId,
        },
        query: {
          filter: JSON.stringify({
            status: options.status,
            runStatus: options.runStatus,
          }),
        },
      },
    },
  );

  handleError(error);

  if (!data) {
    throw new Error("no test cases found");
  }

  return data;
};

export const getTestCaseCode = async (
  options: GetTestCaseParams &
    ListOptions & {
      url: string;
      environmentId?: string;
    },
): Promise<void> => {
  if (options.environmentId === "default") {
    const environments = await getEnvironments({
      testTargetId: options.testTargetId,
    });
    options.environmentId = environments.find((e) => e.type === "DEFAULT")?.id;
    if (!options.environmentId) {
      throw new Error("no default environment found");
    }
  }
  const { data, error } = await client.GET(
    "/apiKey/v3/test-targets/{testTargetId}/test-cases/{testCaseId}/code",
    {
      params: {
        path: {
          testTargetId: options.testTargetId,
          testCaseId: options.testCaseId,
        },
        query: {
          executionUrl: options.url,
          environmentId: options.environmentId,
          simpleCode: true,
        },
      },
    },
  );

  handleError(error);

  if (options.json) {
    logJson(data);
    return;
  }

  if (!data) {
    throw new Error("no test code found");
  }
  logger.info(data.testCode);
};

export const listTestCases = async (
  options: GetTestCasesOptions & ListOptions,
): Promise<void> => {
  if (!options.status) {
    options.status = "ENABLED";
  }
  const testCases = await getTestCases(options);

  if (options.json) {
    logJson(testCases);
    return;
  }

  logger.info("Test Cases:");
  for (let idx = 0; idx < testCases.length; idx++) {
    const testCase = testCases[idx];
    const idxString = `${idx + 1}. `.padEnd(
      testCases.length.toString().length + 2,
    );
    const paddingString = " ".repeat(idxString.length);
    logger.info(`${idxString}Description: ${testCase.description}`);
    logger.info(`${paddingString}ID: ${testCase.id}`);
    logger.info(
      `${paddingString}${await getUrl({
        testCaseId: testCase.id,
        entityType: "test-case",
      })}`,
    );
  }
};
